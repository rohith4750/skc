// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}


enum OrderStatus {
  pending
  in_progress
  completed
  cancelled
}

enum PaymentStatus {
  pending
  partial
  paid
}

enum UserRole {
  admin
  super_admin
}

enum StockTransactionType {
  in
  out
}

enum InventoryCondition {
  good
  fair
  damaged
  repair
}

enum OrderType {
  EVENT
  LUNCH_PACK
}

enum OrderSource {
  ADMIN
  CUSTOMER
}

model CustomerUser {
  id               String    @id @default(uuid())
  customerId       String    @unique
  customer         Customer  @relation(fields: [customerId], references: [id])
  phone            String    @unique
  email            String    @unique
  username         String    @unique
  passwordHash     String
  resetToken       String?
  resetTokenExpiry DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  @@map("customer_users")
}

model CustomerOtp {
  id         String   @id @default(uuid())
  phone      String
  code       String
  source     String?
  expiresAt  DateTime
  verifiedAt DateTime?
  attempts   Int      @default(0)
  createdAt  DateTime @default(now())

  @@index([phone, code])
  @@index([phone, createdAt])
  @@map("customer_otps")
}

model CustomerSession {
  id          String   @id @default(uuid())
  customerId  String
  customer    Customer @relation(fields: [customerId], references: [id])
  token       String   @unique
  createdAt   DateTime @default(now())
  expiresAt   DateTime
  userAgent   String?
  ipAddress   String?
  revokedAt   DateTime?

  @@map("customer_sessions")
}

model Customer {
  id        String            @id @default(uuid())
  name      String
  phone     String
  email     String
  address   String
  message   String?
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
  orders    Order[]
  sessions  CustomerSession[]
  user      CustomerUser?

  @@map("customers")
}

model Enquiry {
  id        String   @id @default(uuid())
  name      String
  phone     String
  email     String
  subject   String
  message   String
  source    String
  createdAt DateTime @default(now())

  @@map("enquiries")
}

model MenuItem {
  id              String  @id @default(uuid())
  name            String
  nameTelugu      String?
  type            String
  description     String?
  descriptionTelugu String?
  isActive        Boolean @default(true)
  orders          OrderItem[]

  @@map("menu_items")
}

model Supervisor {
  id                  String  @id @default(uuid())
  name                String
  email               String
  phone               String
  cateringServiceName String
  isActive            Boolean @default(true)
  orders              Order[]

  @@map("supervisors")
}

model Order {
  id              String    @id @default(uuid())
  serialNumber    Int       @default(autoincrement())
  customerId      String
  customer        Customer  @relation(fields: [customerId], references: [id], onDelete: Cascade)
  supervisorId    String?
  supervisor      Supervisor? @relation(fields: [supervisorId], references: [id], onDelete: SetNull)
  items           OrderItem[]
  orderType       OrderType?   @default(EVENT)
  orderSource     OrderSource? @default(ADMIN)
  totalAmount     Decimal   @db.Decimal(10, 2)
  advancePaid     Decimal   @default(0) @db.Decimal(10, 2)
  remainingAmount Decimal   @db.Decimal(10, 2)
  status          OrderStatus @default(pending)
  mealTypeAmounts Json?
  stalls          Json?
  transportCost   Decimal   @default(0) @db.Decimal(10, 2)
  discount        Decimal   @default(0) @db.Decimal(10, 2)
  eventName       String?
  eventType       String?
  eventDate       DateTime?
  timeSlot        String?
  venueType       String?
  venue           String?
  venueAddress    String?
  city            String?
  menuPackage     String?
  specialRequests String?
  internalNote    String?
  sourceDomain    String?
  customerContactName  String?
  customerContactEmail String?
  customerContactPhone String?
  services        Json?
  numberOfMembers Int?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  bill            Bill?     // âœ… FIXED
  expenses        Expense[]

  @@map("orders")
}


model OrderItem {
  id         String   @id @default(uuid())
  orderId    String
  order      Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  menuItemId String
  menuItem   MenuItem @relation(fields: [menuItemId], references: [id])
  quantity   Int?     @default(1)
  mealType   String?  // Stores which meal type (breakfast/lunch/dinner) this item was selected for
  customization String? // Custom notes for the item (e.g., spice level, onions)

  @@map("order_items")
}

model Bill {
  id              String   @id @default(uuid())
  serialNumber    Int      @unique @default(autoincrement())
  orderId         String   @unique
  order           Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  totalAmount     Decimal   @db.Decimal(10, 2)
  advancePaid     Decimal   @default(0) @db.Decimal(10, 2)
  remainingAmount Decimal   @db.Decimal(10, 2)
  paidAmount      Decimal   @default(0) @db.Decimal(10, 2)
  status          PaymentStatus @default(pending)
  paymentHistory  Json?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@map("bills")
}


model Expense {
  id                 String   @id @default(uuid())
  orderId            String?
  order              Order?   @relation(fields: [orderId], references: [id], onDelete: SetNull)
  category           String   // supervisor, chef, labours, boys, transport, gas, pan, store, other
  amount             Decimal  @db.Decimal(10, 2)
  paidAmount         Decimal  @default(0) @db.Decimal(10, 2) // Actual amount paid (can be less than amount for partial payment)
  paymentStatus      PaymentStatus @default(pending) // pending, partial, paid
  description        String?
  recipient          String?  // Name of person/vendor receiving payment
  paymentDate        DateTime @default(now())
  eventDate          DateTime? // Event date for labours and boys
  notes              String?
  calculationDetails Json?    // Store calculation details: { method: 'plate-wise'|'total', plates?: number, numberOfLabours?: number, numberOfBoys?: number, perUnitAmount?: number }
  // Bulk Allocation Fields
  isBulkExpense      Boolean  @default(false)  // True if this expense covers multiple events
  bulkAllocations    Json?    // Array of { orderId: string, orderName: string, amount: number, percentage?: number }
  allocationMethod   String?  // "equal", "manual", "by-plates", "by-percentage" 
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  @@map("expenses")
}

model User {
  id                String   @id @default(uuid())
  username          String   @unique
  email             String   @unique
  passwordHash      String
  role              UserRole @default(admin) // "admin" or "super_admin" only
  resetToken        String?
  resetTokenExpiry  DateTime?
  isActive          Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  loginLogs         LoginAuditLog[]

  @@map("users")
}

model LoginAuditLog {
  id          String   @id @default(uuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  username    String
  ipAddress   String?
  userAgent   String?  // Browser/device info
  device      String?  // Parsed device type: "Desktop", "Mobile", "Tablet"
  browser     String?  // Parsed browser name
  os          String?  // Operating system
  location    String?  // Approximate location (optional)
  loginTime   DateTime @default(now())
  success     Boolean  @default(true)
  failReason  String?  // If login failed, store reason

  @@map("login_audit_logs")
}

model Workforce {
  id        String   @id @default(uuid())
  name      String
  role      String   // "chef", "supervisor", "transport"
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("workforce")
}

model Stock {
  id          String            @id @default(uuid())
  name        String
  category    String            // "gas", "store", "vegetables", "disposables"
  unit        String            // "kg", "liters", "pieces", "boxes", etc.
  currentStock Decimal          @default(0) @db.Decimal(10, 2)
  minStock    Decimal?          @db.Decimal(10, 2) // Minimum stock level for alerts
  maxStock    Decimal?          @db.Decimal(10, 2) // Maximum stock level
  price       Decimal?          @db.Decimal(10, 2) // Price per unit (optional)
  supplier    String?           // Supplier/vendor name
  location    String?           // Storage location
  description String?
  isActive    Boolean           @default(true)
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  transactions StockTransaction[]

  @@map("stock")
}

model StockTransaction {
  id          String   @id @default(uuid())
  stockId     String
  stock       Stock    @relation(fields: [stockId], references: [id], onDelete: Cascade)
  type        StockTransactionType   // "in" or "out"
  quantity    Decimal  @db.Decimal(10, 2)
  price       Decimal? @db.Decimal(10, 2)  // Price per unit at time of transaction
  totalAmount Decimal? @db.Decimal(10, 2)  // Total amount (quantity * price)
  reference   String?  // Reference number, invoice number, etc.
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("stock_transactions")
}

model Inventory {
  id          String            @id @default(uuid())
  name        String
  category    String            // "glasses", "vessels", "cooking_utensils", "serving_items", "storage", "other"
  quantity    Int               @default(0)
  minQuantity Int?              // Minimum quantity level for alerts
  unit        String            // "pieces", "sets", "units"
  condition   InventoryCondition @default(good) // "good", "fair", "damaged", "repair"
  location    String?           // Storage location
  supplier    String?           // Supplier/vendor name
  purchaseDate DateTime?        // Purchase date
  purchasePrice Decimal?        @db.Decimal(10, 2) // Purchase price
  description String?
  isActive    Boolean           @default(true)
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  @@map("inventory")
}
